<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Java Script 编码规范 | 水刃</title>
  <meta name="author" content="hustcer">
  
  <meta name="description" content="javascript 前端开发规范">
  
  <meta name="keywords" content="topdna,水刃,javascript,前端规范,前端代码风格,编码风格">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Java Script 编码规范"/>
  <meta property="og:site_name" content="水刃"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="水刃" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link href="//netdna.bootstrapcdn.com/font-awesome/3.2.1/css/font-awesome.css" rel="stylesheet">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
  
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-45019001-1', 'topdna.org');
  ga('send', 'pageview');

</script>


</head>


<body>
  <!--[if lte IE 8]> <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'> <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode"><img src="http://storage.ie6countdown.com/assets/100/images/banners/warning_bar_0027_Simplified Chinese.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today." style='margin-left:auto;margin-right:auto;display: block;'/></a></div> <![endif]-->
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">水刃</a></h1>
  <h2><a href="/">Since 2013/09/01 &nbsp;&nbsp;&nbsp;&nbsp;小站新开，欢迎常来</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">首页</a></li>
    
      <li><a href="http://traceinvest.com">TraceInvest</a></li>
    
      <li><a href="/categories/essay/">随感</a></li>
    
      <li><a href="/categories/tech/">技术</a></li>
    
      <li><a href="/categories/investment/">理财</a></li>
    
      <li><a href="/categories/life/">生活</a></li>
    
      <li><a href="/archives">归档</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2013-08-25T07:07:42.000Z"><a href="/tech/js-style/">8月 25 2013</a></time>
      
      
  
    <h1 class="title">Java Script 编码规范</h1>
  

    </header>
    <div class="entry">
      
        <h4 id="-">以下文档大多来自:</h4>
<ul>
<li><a href="http://wyz.67ge.com/google-js/javascriptguide.xml" target="_blank">Google JavaScript 编码规范指南</a></li>
<li><a href="https://github.com/rwldrn/idiomatic.js/tree/master/translations/zh_CN" target="_blank">Idiomatic 风格</a></li>
</ul>
<h4 id="-">参考规范</h4>
<ul>
<li><a href="http://es5.github.com/" target="_blank">ECMAScript 5.1 注解版</a></li>
<li><a href="http://ecma-international.org/ecma-262/5.1/" target="_blank">EcmaScript 语言规范, 5.1 版</a></li>
</ul>
<h4 id="-">基本原则: 无论有多少人在维护，所有在代码仓库中的代码理应看起来像同一个人写的。</h4>
<h2 id="-">前言</h2>
<p>下面的章节描述的是一个 <em>合理</em> 的现代 JavaScript 开发风格指南，并非硬性规定。其想送出的核心理念是<em>高度统一的代码风格</em>（the law of code style consistency）。你为项目所择风格都应为最高准则。作为一个描述放置于你的项目中，并链接到这个文档作为代码风格一致性、可读性和可维护性的保证。</p>
<h2 id="-">规范概要</h2>
<ol>
<li>JS/CSS 文件编码统一采用 UTF8 编码</li>
<li>代码缩进使用 4 个空格缩进替代 tab 缩进</li>
<li>一行代码长度尽量保持 80 列左右</li>
<li>如果编辑器支持在文件保存的时候自动删除行末和空行中的空格 (注意: 要么全部采用，要么全不采用，否则会产生过多的 diff 信息)</li>
<li>JS/CSS 最终发布到产品中的时候需要被压缩，以减小静态资源文件大小，提升页面加载速度</li>
<li>JS 里声明变量必须加上 var 关键字，推荐一个 var 同时声明多个变量，或者一组有逻辑关系的变量，避免一个变量一个 var.</li>
<li>使用 Array 和 Object 语法直接声明并将其初始化, 更易读且性能更好, 而不使用 Array 和 Object 构造器.</li>
<li>JS 里使用单引号 (&#39;) 优于双引号 (&quot;).</li>
<li>JS 代码结尾统一约定加 &#39;;&#39;</li>
<li>没有特殊原因避免使用 with/eval</li>
<li>对于 if/else 等后面的语句即使只有一行代码也需要在该行代码的首尾加上 &#39;{}&#39;.</li>
<li>字符串拼接在少量 (次数为个位数) 的情况下可以使用 &#39;+&#39;, 大量的时候使用数组 join(), 或者尽可能采用模板引擎渲染：比如 jsRender 等, 如果是 Extjs 可以采用 XTemplate.</li>
<li>对于数组赋值操作快于 push() 操作, 所以尽量使用赋值操作.</li>
<li>for 循环遍历：for(var i = 0, l = arr.length; i &lt; l; i++){// doSomething here } 采用这种方式而不是 i &lt; arr.length, 前一种方式只会计算一次 arr 的长度，而后一种方式会计算数组长度 arr.length + 1 次，效率比较低</li>
<li>字符串转换为整数，推荐使用 parseInt(num, 10) 这种方式，+num 写法简单，在操作次数极少的情况下也可以酌情使用。</li>
<li>变量比较的时候总是判断最好、最精确的值，推荐使用 &#39;===&#39; 少用 &#39;==&#39;(可以参考<a href="https://github.com/jquery/jquery/blob/master/src/core.js" target="_blank">jQuery</a>代码里面, 可以看到只有在 &#39;== null&#39; 的时候才可能使用 &#39;==&#39;，其他情况一律使用的是 &#39;===&#39;).</li>
<li>JS 里变量命名规范使用 functionNamesLikeThis, variableNamesLikeThis, ClassNamesLikeThis, EnumNamesLikeThis, methodNamesLikeThis, 和 SYMBOLIC_CONSTANTS_LIKE_THIS, 尤其不要跟 python 里面的变量命名方式混淆了.</li>
<li>JS 文件名应该使用小写字符, 以避免在有些系统平台上不识别大小写的命名方式. 文件名以.js 结尾, 不要包含除 &#39;-&#39; 和 &#39;<em>&#39; 外的标点符号 (使用 &#39;-&#39; 优于 &#39;</em>&#39;), 我们约定统一使用 js-file-name.js 这种类型，对于 template 文件命名方式为 template_name.html 形式.</li>
<li>所有的 html DOM 里面的 id, Extjs 配置项里面的 id 以及所有样式里面的 class 命名使用中划线，如 &#39;id-name&#39;/&#39;class-name&#39;.</li>
<li>公共的 js 第三方类库放在 static/js/common/lib 下，jQuery 相关类库放在 static/js/common/lib/jQplugin 下，我们自己开发的公共类库放在 static/js/common 下</li>
<li>鉴于有很多代码是复制粘贴过来的，所以大家要保证自己的代码风格良好且易于阅读，不然别人拷过去后不好的风格就蔓延开了，而且会导致其他人效仿。</li>
<li>对于复制粘贴然后做相应修改以实现功能的代码，请务必清理干净，不要有 &#39; 忘了删除的不影响逻辑的代码 &#39;，同时记得将变量名改成适合当前业务场景的有意义的变量名, 不要因为不影响逻辑就保留原来的不适合当前场景的名字</li>
<li>对于系统中出现的大段注释的、过时的、废弃的代码务必及时清理干净，谁制造谁清理，否则其他人也不敢清理，越积越多</li>
<li>不要使用魔法数字，尽量定义一个常量来表示该数字，并加上相应的注释，否则后期可能出现因为数字变化而导致牵一发而动全身，需要到处修改，增加维护成本</li>
<li>注释尽量采用 jsdoc 的代码注释风格，普通业务代码不做要求，不过通用 js 类库要求尽量详尽以方便其他人阅读使用</li>
<li>在开发相应功能的时候尽量抽象化、组件化、通用化：考虑这个东西其他地方会不会用到，能不能做成一个组件？而不是类似的代码到处复制、修改或者让大家都去写一遍</li>
<li>类似地，在解决问题的时候要考虑下其他地方会不会存在同样的问题？能不能统一解决掉？尤其对于类似 ExtJs 的 Bug 这种，能不能做最少的改动解决所有同样的问题, 类似于全局补丁.</li>
<li>代码风格跟其他 JS 文件的代码风格保持一致</li>
<li>新增、修改、查看等表单在 popup 的时候需要重新初始化清除原来数据</li>
<li>代码提交前用 JSHint 检查一下</li>
</ol>
<a id="more"></a>

<h2 id="-build">前端资源 Build</h2>
<p>项目必须总是提供一些通用的方法来检验（can be linted）、测试和压缩源码以为产品阶段使用做准备。对于此类工作 Ben Alman 所写的 <a href="https://github.com/cowboy/grunt" target="_blank">grunt</a> 可谓首屈一指。通过简单的配置即可完成自动对 CSS 进行检查 / 压缩 / 合并，对 JS 进行检查 / 压缩 / 合并，对 html 文件进行压缩，删除创建目录，拷贝文件，压缩打包等，十分方便。
参考的 grunt 配置文件:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
</pre></td><td class="code"><pre><span class="comment">/**
 * Grunt file for front end resource check/minify/compress.
 */</span>
module.exports = <span class="function"><span class="keyword">function</span><span class="params">(grunt)</span> {</span>

  grunt.initConfig({
    pkg: grunt.file.readJSON(<span class="string">'package.json'</span>),
    jshint: {
      options: {
        asi       : <span class="literal">true</span>,
        curly     : <span class="literal">false</span>,
        eqeqeq    : <span class="literal">true</span>,
        immed     : <span class="literal">false</span>,
        latedef   : <span class="literal">true</span>,
        newcap    : <span class="literal">true</span>,
        noarg     : <span class="literal">true</span>,
        sub       : <span class="literal">true</span>,
        undef     : <span class="literal">true</span>,
        boss      : <span class="literal">true</span>,
        eqnull    : <span class="literal">true</span>,
        smarttabs : <span class="literal">true</span>,
        browser   : <span class="literal">true</span>,
        jquery    : <span class="literal">true</span>,
        white     : <span class="literal">false</span>,
        laxbreak  : <span class="literal">false</span>,
        laxcomma  : <span class="literal">true</span>,
        expr      : <span class="literal">true</span>,
        devel     : <span class="literal">false</span>,
        globals   : {
          module    : <span class="literal">true</span>,
          Mousetrap : <span class="literal">true</span>,
          jQuery    : <span class="literal">true</span>
        }
      },
      all: [<span class="string">'Gruntfile.js'</span>, <span class="string">'js/**/*.js'</span>, <span class="string">'!js/**/*.min.js'</span>, <span class="string">'!js/json2.js'</span>, <span class="string">'!js/jquery.simplemodal.js'</span>]
    },
    clean: {
      release: {
        src: [<span class="string">'release/'</span>]
      }
    },
    uglify: {
      options: {
        banner: <span class="string">'/*! &lt;%= pkg.description %&gt;  Ver: &lt;%= pkg.version %&gt;  Date: &lt;%= grunt.template.today("yyyy/mm/dd HH:MM:ss") %&gt; */\n'</span>
      },
      dist: {
        <span class="comment">// Grunt will search for "**/?.js" under "js/" when the "uglify" task</span>
        <span class="comment">// runs and build the appropriate src-dest file mappings then, so you</span>
        <span class="comment">// don't need to update the Gruntfile when files are added or removed.</span>
        files: [
          {
            expand : <span class="literal">true</span>,                                  <span class="comment">// Enable dynamic expansion.</span>
            cwd    : <span class="string">'js/'</span>,                                 <span class="comment">// Src matches are relative to this path.</span>
            src    : [<span class="string">'jquery.simplemodal.js'</span>,<span class="string">'index.js'</span>],  <span class="comment">// Actual pattern(s) to match.</span>
            dest   : <span class="string">'release/js/'</span>                          <span class="comment">// Destination path prefix.</span>
            <span class="comment">// ext : '.js'                                  // Dest filepaths will have this extension. '.min.js' is recommeded.</span>
          }
        ]
      }
    },
    cssmin: {
      minify: {
        expand : <span class="literal">true</span>,
        cwd    : <span class="string">'style/'</span>,
        src    : [<span class="string">'*.css'</span>],
        dest   : <span class="string">'release/style/'</span>,
        ext    : <span class="string">'.css'</span>
      }
    },
    htmlmin: {                                     <span class="comment">// Task</span>
      dist: {                                      <span class="comment">// Target</span>
        options: {                                 <span class="comment">// Target options</span>
          removeComments: <span class="literal">true</span>,
          collapseWhitespace: <span class="literal">true</span>
        },
        files: {                                   <span class="comment">// Dictionary of files</span>
          <span class="string">'release/index.html'</span>: <span class="string">'index.html'</span>       <span class="comment">// 'destination': 'source'</span>
        }
      }
    },
    copy: {
      main: {
        files: [
          {expand: <span class="literal">true</span>, cwd: <span class="string">'.'</span>, src: [<span class="string">'js/*.min.js'</span>, <span class="string">'js/json2.js'</span>, <span class="string">'images/*'</span>], dest: <span class="string">'release/'</span>}
        ]
      }
    },
    compress: {
      main: {
        options: {
          archive: <span class="string">'release/executable.zip'</span>         <span class="comment">// make a zipfile</span>
        },
        files: [
          <span class="comment">// {src: ['release/**'], dest: 'release/'},                        // includes files in path and its subdirs</span>
          {expand: <span class="literal">true</span>, cwd: <span class="string">'release/'</span>, src: [<span class="string">'**'</span>], dest: <span class="string">'executable/'</span>}  <span class="comment">// makes all src relative to cwd</span>
        ]
      }
    }

  });

  grunt.loadNpmTasks(<span class="string">'grunt-contrib-jshint'</span>);
  grunt.loadNpmTasks(<span class="string">'grunt-contrib-clean'</span>);
  grunt.loadNpmTasks(<span class="string">'grunt-contrib-uglify'</span>);
  grunt.loadNpmTasks(<span class="string">'grunt-contrib-cssmin'</span>);
  grunt.loadNpmTasks(<span class="string">'grunt-contrib-htmlmin'</span>);
  grunt.loadNpmTasks(<span class="string">'grunt-contrib-copy'</span>);
  grunt.loadNpmTasks(<span class="string">'grunt-contrib-compress'</span>);

  grunt.registerTask(<span class="string">'min'</span>    , [<span class="string">'clean'</span>, <span class="string">'uglify'</span>, <span class="string">'cssmin'</span>, <span class="string">'htmlmin'</span>, <span class="string">'copy'</span>, <span class="string">'compress'</span>]);
  grunt.registerTask(<span class="string">'check'</span>  , [<span class="string">'jshint'</span>]);
  grunt.registerTask(<span class="string">'default'</span>, [<span class="string">'jshint'</span>, <span class="string">'clean'</span>, <span class="string">'uglify'</span>, <span class="string">'cssmin'</span>, <span class="string">'htmlmin'</span>, <span class="string">'copy'</span>, <span class="string">'compress'</span>]);

};
</pre></td></tr></table></figure>

<h2 id="-">规范详情</h2>
<h3 id="javascript-">JavaScript 编码风格</h3>
<h4 id="-">空白</h4>
<ul>
<li>永远都不要混用空格和 Tab。</li>
<li>开始一个项目，在写代码之前，选择软缩进（空格）或者 Tab（作为缩进方式），并将其作为<strong>最高准则</strong>。<ul>
<li>为了可读, 我总是推荐在你的编辑中设计 4 个字母宽度的缩进 &mdash; 这等同于四个空格或者四个空格替代一个 Tab。</li>
</ul>
</li>
<li>如果你的编辑器支持，请总是打开 “显示不可见字符” 这个设置。好处是：<ul>
<li>保证一致性</li>
<li>去掉行末的空格</li>
<li>去掉空行的空格</li>
<li>提交和对比更具可读性</li>
</ul>
</li>
</ul>
<h4 id="-">行末和空行</h4>
<p>留白会破坏 diff 并使 diff 结果变得更不可读。考虑包括一个预提交的 hook 自动删除行末和空行中的空格。</p>
<h4 id="-">花括号, 换行</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>
    <span class="comment">// if/else/for/while/try 通常都有小括号、花括号和多行</span>
    <span class="comment">// 这有助于可读, 以下是很糟糕的写法</span>

    <span class="keyword">if</span>(condition) doSomething();

    <span class="keyword">while</span>(condition) iterating++;

    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++) someIterativeFn();
</pre></td></tr></table></figure>

<h4 id="-">命名</h4>
<p>通常, 使用 functionNamesLikeThis, variableNamesLikeThis, ClassNamesLikeThis, EnumNamesLikeThis, methodNamesLikeThis, 和 SYMBOLIC_CONSTANTS_LIKE_THIS.</p>
<h5 id="-">属性和方法</h5>
<p>文件或类中的 私有 属性, 变量和方法名应该以下划线 &quot;_&quot; 开头.
保护 属性, 变量和方法名不需要下划线开头, 和公共变量名一样.</p>
<h5 id="-">方法和函数参数</h5>
<p>可选参数以 opt_ 开头.</p>
<p>函数的参数个数不固定时, 应该添加最后一个参数 var_args 为参数的个数. 你也可以不设置 var_args 而取代使用 arguments.</p>
<p>可选和可变参数应该在 @param 标记中说明清楚. 虽然这两个规定对编译器没有任何影响, 但还是请尽量遵守</p>
<h5 id="getters-setters">Getters 和 Setters</h5>
<p>Getters 和 setters 并不是必要的. 但只要使用它们了, 就请将 getters 命名成 getFoo() 形式, 将 setters 命名成 setFoo(value) 形式. (对于布尔类型的 getters, 使用 isFoo() 也可.)</p>
<h4 id="-">命名空间</h4>
<p>JavaScript 不支持包和命名空间.
不容易发现和调试全局命名的冲突, 多个系统集成时还可能因为命名冲突导致很严重的问题. 为了提高 JavaScript 代码复用率, 我们遵循下面的约定以避免冲突.</p>
<h5 id="-">为全局代码使用命名空间</h5>
<p>在全局作用域上, 使用一个唯一的, 与工程 / 库相关的名字作为前缀标识. 比如, 你的工程是 &quot;Project Sloth&quot;, 那么命名空间前缀可取为 sloth.*.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="keyword">var</span> sloth = {};

sloth.sleep = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  ...
};
</pre></td></tr></table></figure>

<p>许多 JavaScript 库, 包括 the Closure Library and Dojo toolkit 为你提供了声明你自己的命名空间的函数. 比如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>goog.provide(<span class="string">'sloth'</span>);

sloth.sleep = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  ...
};
</pre></td></tr></table></figure>

<h5 id="-">明确命名空间所有权</h5>
<p>当选择了一个子命名空间, 请确保父命名空间的负责人知道你在用哪个子命名空间, 比如说, 你为工程 &#39;sloths&#39; 创建一个 &#39;hats&#39; 子命名空间, 那确保 Sloth 团队人员知道你在使用 sloth.hats.</p>
<h5 id="-">外部代码和内部代码使用不同的命名空间</h5>
<p>&quot; 外部代码 &quot; 是指来自于你代码体系的外部, 可以独立编译. 内外部命名应该严格保持独立. 如果你使用了外部库, 他的所有对象都在 foo.hats.<em> 下, 那么你自己的代码不能在 foo.hats.</em>下命名, 因为很有可能其他团队也在其中命名.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>foo.require(<span class="string">'foo.hats'</span>);

<span class="comment">/**
 * WRONG -- Do NOT do this.
 * @constructor
 * @extend {foo.hats.RoundHat}
 */</span>
foo.hats.BowlerHat = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
};
</pre></td></tr></table></figure>

<h4 id="-">重命名那些名字很长的变量, 提高可读性</h4>
<p>主要是为了提高可读性. 局部空间中的变量别名只需要取原名字的最后部分.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="comment">/**
 * @constructor
 */</span>
some.long.namespace.MyClass = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
};

<span class="comment">/**
 * @param {some.long.namespace.MyClass} a
 */</span>
some.long.namespace.MyClass.staticHelper = <span class="function"><span class="keyword">function</span><span class="params">(a)</span> {</span>
  ...
};

myapp.main = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> MyClass = some.long.namespace.MyClass;
  <span class="keyword">var</span> staticHelper = some.long.namespace.MyClass.staticHelper;
  staticHelper(<span class="keyword">new</span> MyClass());
};
</pre></td></tr></table></figure>

<h4 id="-">除非是枚举类型, 不然不要访问别名变量的属性.</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="comment">/** @enum {string} */</span>
some.long.namespace.Fruit = {
  APPLE: <span class="string">'a'</span>,
  BANANA: <span class="string">'b'</span>
};

myapp.main = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> Fruit = some.long.namespace.Fruit;
  <span class="keyword">switch</span> (fruit) {
    <span class="keyword">case</span> Fruit.APPLE:
      ...
    <span class="keyword">case</span> Fruit.BANANA:
      ...
  }
};
myapp.main = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> MyClass = some.long.namespace.MyClass;
  MyClass.staticHelper(<span class="literal">null</span>);
};
</pre></td></tr></table></figure>

<p>不要在全局范围内创建别名, 而仅在函数块作用域中使用.</p>
<h4 id="-">文件名</h4>
<p>文件名应该使用小写字符, 以避免在有些系统平台上不识别大小写的命名方式. 文件名以.js 结尾, 不要包含除 - 和 <em> 外的标点符号 (使用 - 优于 </em>).</p>
<h4 id="-tostring-">自定义 toString() 方法</h4>
<p>应该总是成功调用且不要抛异常.
可自定义 toString() 方法, 但确保你的实现方法满足: (1) 总是成功 (2) 没有其他负面影响. 如果不满足这两个条件, 那么可能会导致严重的问题, 比如, 如果 toString() 调用了包含 assert 的函数, assert 输出导致失败的对象, 这在 toString() 也会被调用.</p>
<h4 id="-">延迟初始化</h4>
<p>可以
没必要在每次声明变量时就将其初始化.</p>
<h4 id="-">明确作用域</h4>
<p>任何时候都需要
任何时候都要明确作用域 - 提高可移植性和清晰度. 例如, 不要依赖于作用域链中的 window 对象. 可能在其他应用中, 你函数中的 window 不是指之前的那个窗口对象.</p>
<h4 id="-">代码格式化</h4>
<h5 id="-">大括号</h5>
<p>分号会被隐式插入到代码中, 所以你务必在同一行上插入大括号. 例如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>  <span class="keyword">if</span> (something) {
    <span class="comment">// ...</span>
  } <span class="keyword">else</span> {
    <span class="comment">// ...</span>
  }
</pre></td></tr></table></figure>

<h5 id="-">数组和对象的初始化</h5>
<p>如果初始值不是很长, 就保持写在单行上:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];  <span class="comment">// No space after [ or before ].</span>
<span class="keyword">var</span> obj = {a: <span class="number">1</span>, b: <span class="number">2</span>, c: <span class="number">3</span>};  <span class="comment">// No space after { or before }.</span>
</pre></td></tr></table></figure>

<p>初始值占用多行时, 缩进 2 个空格.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="comment">// Object initializer.</span>
<span class="keyword">var</span> inset = {
  top: <span class="number">10</span>,
  right: <span class="number">20</span>,
  bottom: <span class="number">15</span>,
  left: <span class="number">12</span>
};

<span class="comment">// Array initializer.</span>
<span class="keyword">this</span>.rows_ = [
  <span class="string">'"Slartibartfast" &lt;fjordmaster@magrathea.com&gt;'</span>,
  <span class="string">'"Zaphod Beeblebrox" &lt;theprez@universe.gov&gt;'</span>,
  <span class="string">'"Ford Prefect" &lt;ford@theguide.com&gt;'</span>,
  <span class="string">'"Arthur Dent" &lt;has.no.tea@gmail.com&gt;'</span>,
  <span class="string">'"Marvin the Paranoid Android" &lt;marv@googlemail.com&gt;'</span>,
  <span class="string">'the.mice@magrathea.com'</span>
];

<span class="comment">// Used in a method call.</span>
goog.dom.createDom(goog.dom.TagName.DIV, {
  id: <span class="string">'foo'</span>,
  className: <span class="string">'some-css-class'</span>,
  style: <span class="string">'display:none'</span>
}, <span class="string">'Hello, world!'</span>);
</pre></td></tr></table></figure>

<h5 id="-">函数参数</h5>
<p>尽量让函数参数在同一行上. 如果一行超过 80 字符, 每个参数独占一行, 并以 4 个空格缩进, 或者与括号对齐, 以提高可读性. 尽可能不要让每行超过 80 个字符. 比如下面这样:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre><span class="comment">// Four-space, wrap at 80.  Works with very long function names, survives</span>
<span class="comment">// renaming without reindenting, low on space.</span>
goog.foo.bar.doThingThatIsVeryDifficultToExplain = <span class="function"><span class="keyword">function</span><span class="params">(
    veryDescriptiveArgumentNumberOne, veryDescriptiveArgumentTwo,
    tableModelEventHandlerProxy, artichokeDescriptorAdapterIterator)</span> {</span>
  <span class="comment">// ...</span>
};

<span class="comment">// Four-space, one argument per line.  Works with long function names,</span>
<span class="comment">// survives renaming, and emphasizes each argument.</span>
goog.foo.bar.doThingThatIsVeryDifficultToExplain = <span class="function"><span class="keyword">function</span><span class="params">(
    veryDescriptiveArgumentNumberOne,
    veryDescriptiveArgumentTwo,
    tableModelEventHandlerProxy,
    artichokeDescriptorAdapterIterator)</span> {</span>
  <span class="comment">// ...</span>
};

<span class="comment">// Parenthesis-aligned indentation, wrap at 80.  Visually groups arguments,</span>
<span class="comment">// low on space.</span>
<span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(veryDescriptiveArgumentNumberOne, veryDescriptiveArgumentTwo,
             tableModelEventHandlerProxy, artichokeDescriptorAdapterIterator)</span> {</span>
  <span class="comment">// ...</span>
}

<span class="comment">// Parenthesis-aligned, one argument per line.  Visually groups and</span>
<span class="comment">// emphasizes each individual argument.</span>
<span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">(veryDescriptiveArgumentNumberOne,
             veryDescriptiveArgumentTwo,
             tableModelEventHandlerProxy,
             artichokeDescriptorAdapterIterator)</span> {</span>
  <span class="comment">// ...</span>
}
</pre></td></tr></table></figure>

<h5 id="-">传递匿名函数</h5>
<p>如果参数中有匿名函数, 函数体从调用该函数的左边开始缩进 2 个空格, 而不是从 function 这个关键字开始. 这让匿名函数更加易读 (不要增加很多没必要的缩进让函数体显示在屏幕的右侧).</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="keyword">var</span> names = items.map(<span class="function"><span class="keyword">function</span><span class="params">(item)</span> {</span>
                        <span class="keyword">return</span> item.name;
                      });

prefix.something.reallyLongFunctionName(<span class="string">'whatever'</span>, <span class="function"><span class="keyword">function</span><span class="params">(a1, a2)</span> {</span>
  <span class="keyword">if</span> (a1.equals(a2)) {
    someOtherLongFunctionName(a1);
  } <span class="keyword">else</span> {
    andNowForSomethingCompletelyDifferent(a2.parrot);
  }
});
</pre></td></tr></table></figure>

<h5 id="-">更多的缩进</h5>
<p>事实上, 除了 初始化数组和对象 , 和传递匿名函数外, 所有被拆开的多行文本要么选择与之前的表达式左对齐, 要么以 4 个 (而不是 2 个) 空格作为一缩进层次.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre>someWonderfulHtml = <span class="string">''</span> +
                    getEvenMoreHtml(someReallyInterestingValues, moreValues,
                                    evenMoreParams, <span class="string">'a duck'</span>, <span class="literal">true</span>, <span class="number">72</span>,
                                    slightlyMoreMonkeys(<span class="number">0xfff</span>)) +
                    <span class="string">''</span>;

thisIsAVeryLongVariableName =
    hereIsAnEvenLongerOtherFunctionNameThatWillNotFitOnPrevLine();

thisIsAVeryLongVariableName = <span class="string">'expressionPartOne'</span> + someMethodThatIsLong() +
    thisIsAnEvenLongerOtherFunctionNameThatCannotBeIndentedMore();

someValue = <span class="keyword">this</span>.foo(
    shortArg,
    <span class="string">'Some really long string arg - this is a pretty common case, actually.'</span>,
    shorty2,
    <span class="keyword">this</span>.bar());

<span class="keyword">if</span> (searchableCollection(allYourStuff).contains(theStuffYouWant) &&
    !ambientNotification.isActive() && (client.isAmbientSupported() ||
                                        client.alwaysTryAmbientAnyways()) {
  ambientNotification.activate();
}
</pre></td></tr></table></figure>

<h5 id="-">空行</h5>
<p>使用空行来划分一组逻辑上相关联的代码片段.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>doSomethingTo(x);
doSomethingElseTo(x);
andThen(x);

nowDoSomethingWith(y);

andNowWith(z);
</pre></td></tr></table></figure>

<h5 id="-">二元和三元操作符</h5>
<p>操作符始终跟随着前行, 这样就不用顾虑分号的隐式插入问题. 如果一行实在放不下, 还是按照上述的缩进风格来换行.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="keyword">var</span> x = a ? b : c;  <span class="comment">// All on one line if it will fit.</span>

<span class="comment">// Indentation +4 is OK.</span>
<span class="keyword">var</span> y = a ?
    longButSimpleOperandB : longButSimpleOperandC;

<span class="comment">// Indenting to the line position of the first operand is also OK.</span>
<span class="keyword">var</span> z = a ?
        moreComplicatedB :
        moreComplicatedC;
</pre></td></tr></table></figure>

<h5 id="-">括号</h5>
<p>只在需要的时候使用
不要滥用括号, 只在必要的时候使用它.</p>
<p>对于一元操作符 (如 delete, typeof 和 void ), 或是在某些关键词 (如 return, throw, case, new ) 之后, 不要使用括号.</p>
<h5 id="-">字符串</h5>
<p>使用 &#39; 优于 &quot;
无论你选择单引号还是双引号都无所谓，在 JavaScript 中它们在解析上没有区别。而<strong>绝对需要</strong>强制的是一致性。 <strong>永远不要在同一个项目中混用两种引号，选择一种，并保持一致</strong>。</p>
<p>单引号 (&#39;) 优于双引号 (&quot;). 当你创建一个包含 HTML 代码的字符串时就知道它的好处了.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">var</span> msg = <span class="string">'This is some HTML'</span>;
</pre></td></tr></table></figure>

<h5 id="-comma-first-">前置逗号（Comma First）</h5>
<p>请勿使用。所有使用这个文档作为基本风格指南的项目都不允许前置逗号的代码格式，除非明确指定或者作者要求。</p>
<h5 id="-">注释</h5>
<ul>
<li>单行注释放于代码上方为首选</li>
<li>多行也可以</li>
<li>行末注释应被避免!</li>
<li>JSDoc 的方式也不错，但需要比较多的时间</li>
</ul>
<h5 id="-jsdoc">使用 JSDoc</h5>
<p>我们使用 JSDoc 中的注释风格. 行内注释使用 // 变量 的形式. 另外, 我们也遵循 C++ 代码注释风格 . 这也就是说你需要:</p>
<ul>
<li>版权和著作权的信息,</li>
<li>文件注释中应该写明该文件的基本信息 (如, 这段代码的功能摘要, 如何使用, 与哪些东西相关), 来告诉那些不熟悉代码的读者.</li>
<li>类, 函数, 变量和必要的注释,</li>
<li>期望在哪些浏览器中执行,</li>
<li>正确的大小写, 标点和拼写.</li>
<li>为了避免出现句子片段, 请以合适的大 / 小写单词开头, 并以合适的标点符号结束这个句子.</li>
</ul>
<p>现在假设维护这段代码的是一位初学者. 这可能正好是这样的!</p>
<p>目前很多编译器可从 JSDoc 中提取类型信息, 来对代码进行验证, 删除和压缩. 因此, 你很有必要去熟悉正确完整的 JSDoc .</p>
<h5 id="-">顶层 / 文件注释</h5>
<p>顶层注释用于告诉不熟悉这段代码的读者这个文件中包含哪些东西. 应该提供文件的大体内容, 它的作者, 依赖关系和兼容性信息. 如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="comment">// Copyright 2009 Google Inc. All Rights Reserved.</span>

<span class="comment">/**
 * @fileoverview Description of file, its uses and information
 * about its dependencies.
 * @author user@google.com (Firstname Lastname)
 */</span>
</pre></td></tr></table></figure>

<h5 id="-">类注释</h5>
<p>每个类的定义都要附带一份注释, 描述类的功能和用法. 也需要说明构造器参数. 如果该类继承自其它类, 应该使用 @extends 标记. 如果该类是对接口的实现, 应该使用 @implements 标记.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="comment">/**
 * Class making something fun and easy.
 * @param {string} arg1 An argument that makes this more interesting.
 * @param {Array.&lt;number&gt;} arg2 List of numbers to be processed.
 * @constructor
 * @extends {goog.Disposable}
 */</span>
project.MyClass = <span class="function"><span class="keyword">function</span><span class="params">(arg1, arg2)</span> {</span>
  <span class="comment">// ...</span>
};
goog.inherits(project.MyClass, goog.Disposable);
</pre></td></tr></table></figure>

<h5 id="-">方法与函数的注释</h5>
<p>提供参数的说明. 使用完整的句子, 并用第三人称来书写方法说明.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="comment">/**
 * Converts text to some completely different text.
 * @param {string} arg1 An argument that makes this more interesting.
 * @return {string} Some return value.
 */</span>
project.MyClass.prototype.someMethod = <span class="function"><span class="keyword">function</span><span class="params">(arg1)</span> {</span>
  <span class="comment">// ...</span>
};

<span class="comment">/**
 * Operates on an instance of MyClass and returns something.
 * @param {project.MyClass} obj Instance of MyClass which leads to a long
 *     comment that needs to be wrapped to two lines.
 * @return {boolean} Whether something occured.
 */</span>
<span class="function"><span class="keyword">function</span> <span class="title">PR_someMethod</span><span class="params">(obj)</span> {</span>
  <span class="comment">// ...</span>
}
</pre></td></tr></table></figure>

<p>对于一些简单的, 不带参数的 getters, 说明可以忽略.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="comment">/**
 * @return {Element} The element for the component.
 */</span>
goog.ui.Component.prototype.getElement = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">return</span> <span class="keyword">this</span>.element_;
};
</pre></td></tr></table></figure>

<h5 id="-">属性注释</h5>
<p>也需要对属性进行注释.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">/**
 * Maximum number of things per pane.
 * @type {number}
 */</span>
project.MyClass.prototype.someProperty = <span class="number">4</span>;
</pre></td></tr></table></figure>

<h5 id="jsdoc-">JSDoc 缩进</h5>
<p>如果你在 @param, @return, @supported, @this 或 @deprecated 中断行, 需要像在代码中一样, 使用 4 个空格作为一个缩进层次.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="comment">/**
 * Illustrates line wrapping for long param/return descriptions.
 * @param {string} foo This is a param with a description too long to fit in
 *     one line.
 * @return {number} This returns something that has a description too long to
 *     fit in one line.
 */</span>
project.MyClass.prototype.method = <span class="function"><span class="keyword">function</span><span class="params">(foo)</span> {</span>
  <span class="keyword">return</span> <span class="number">5</span>;
};
</pre></td></tr></table></figure>

<p>不要在 @fileoverview 标记中进行缩进.</p>
<p>虽然不建议, 但也可对说明文字进行适当的排版对齐. 不过, 这样带来一些负面影响, 就是当你每次修改变量名时, 都得重新排版说明文字以保持和变量名对齐.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre><span class="comment">/**
 * This is NOT the preferred indentation method.
 * @param {string} foo This is a param with a description too long to fit in
 *                     one line.
 * @return {number} This returns something that has a description too long to
 *                  fit in one line.
 */</span>
project.MyClass.prototype.method = <span class="function"><span class="keyword">function</span><span class="params">(foo)</span> {</span>
  <span class="keyword">return</span> <span class="number">5</span>;
};
</pre></td></tr></table></figure>

<h5 id="-">枚举</h5>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="comment">/**
 * Enum for tri-state values.
 * @enum {number}
 */</span>
project.TriState = {
  TRUE: <span class="number">1</span>,
  FALSE: -<span class="number">1</span>,
  MAYBE: <span class="number">0</span>
};
</pre></td></tr></table></figure>

<p>注意一下, 枚举也具有有效类型, 所以可以当成参数类型来用.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="comment">/**
 * Sets project state.
 * @param {project.TriState} state New project state.
 */</span>
project.setState = <span class="function"><span class="keyword">function</span><span class="params">(state)</span> {</span>
  <span class="comment">// ...</span>
};
</pre></td></tr></table></figure>

<h3 id="javascript-">JavaScript 语言规范</h3>
<h4 id="-">变量</h4>
<p>声明变量必须加上 var 关键字.
当你没有写 var, 变量就会暴露在全局上下文中, 这样很可能会和现有变量冲突. 另外, 如果没有加上, 很难明确该变量的作用域是什么, 变量也很可能像在局部作用域中, 很轻易地泄漏到 Document 或者 Window 中, 所以务必用 var 去声明变量.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="code"><pre>
  <span class="comment">// 变量</span>
  <span class="keyword">var</span> foo = <span class="string">"bar"</span>,
    num = <span class="number">1</span>,
    undef;

  <span class="comment">// 字面量标识:</span>
  <span class="keyword">var</span> array = [],
    object = {};

  <span class="comment">// 在一个作用域（函数）内只使用一个 `var` 有助于提升可读性</span>
  <span class="comment">// 并且让你的声明列表变得有条不紊 (还帮你省了几次键盘敲击)</span>

  <span class="comment">// 不好</span>
  <span class="keyword">var</span> foo = <span class="string">""</span>;
  <span class="keyword">var</span> bar = <span class="string">""</span>;
  <span class="keyword">var</span> qux;

  <span class="comment">// 好的做法</span>
  <span class="keyword">var</span> foo = <span class="string">""</span>,
    bar = <span class="string">""</span>,
    quux;

  <span class="comment">// 或者..</span>
  <span class="keyword">var</span> <span class="comment">// 对这些变量的注释</span>
  foo = <span class="string">""</span>,
  bar = <span class="string">""</span>,
  quux;

  <span class="comment">// `var` 语句必须总是在各自作用域（函数）顶部</span>
  <span class="comment">// 同样适应于来自 ECMAScript 6 的常量</span>

  <span class="comment">// 不好</span>
  <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> {</span>

    <span class="comment">// 在变量前有语句</span>

    <span class="keyword">var</span> bar = <span class="string">""</span>,
      qux;
  }

  <span class="comment">// 好</span>
  <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> bar = <span class="string">""</span>,
      qux;

    <span class="comment">// 所有语句都在变量之后</span>
  }
</pre></td></tr></table></figure>

<h4 id="-">常量</h4>
<p>常量的形式如: NAMES_LIKE_THIS, 即使用大写字符, 并用下划线分隔. 你也可用 @const 标记来指明它是一个常量. 但请永远不要使用 const 关键词.</p>
<p>Decision:
对于基本类型的常量, 只需转换命名.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>
  <span class="comment">/**
   * The number of seconds in a minute.
   * @type {number}
   */</span>
  goog.example.SECONDS_IN_A_MINUTE = <span class="number">60</span>;
</pre></td></tr></table></figure>

<p>对于非基本类型, 使用 @const 标记.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>
  <span class="comment">/**
   * The number of seconds in each of the given units.
   * @type {Object.&lt;number&gt;}
   * @const
   */</span>
  goog.example.SECONDS_TABLE = {
    minute: <span class="number">60</span>,
    hour: <span class="number">60</span> * <span class="number">60</span>,
    day: <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>
  }
</pre></td></tr></table></figure>

<p>这标记告诉编译器它是常量.</p>
<p>至于关键词 const, 因为 IE 不能识别, 所以不要使用.</p>
<h4 id="-">分号</h4>
<p>总是使用分号.</p>
<p>如果仅依靠语句间的隐式分隔, 有时会很麻烦. 你自己更能清楚哪里是语句的起止. 而且有些情况下, 漏掉分号会很危险，可能会导致代码合并错误等，又比如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>
    <span class="comment">// 1.</span>
    MyClass.prototype.myMethod = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
      <span class="keyword">return</span> <span class="number">42</span>;
    }  <span class="comment">// No semicolon here.</span>

    (<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
      <span class="comment">// Some initialization code wrapped in a function to create a scope for locals.</span>
    })();

    <span class="keyword">var</span> THINGS_TO_EAT = [apples, oysters, sprayOnCheese]  <span class="comment">// No semicolon here.</span>

    <span class="comment">// 2. conditional execution a la bash</span>
    -<span class="number">1</span> == resultOfOperation() || die();
</pre></td></tr></table></figure>

<p>这段代码会发生些什么诡异事呢?</p>
<ol>
<li>报 JavaScript 错误 - 例子 1 上的语句会解释成, 一个函数带一匿名函数作为参数而被调用, 返回 42 后, 又一次被 &quot; 调用 &quot;, 这就导致了错误.</li>
<li>当 resultOfOperation() 返回非 NaN 时, 就会调用 die, 其结果也会赋给 THINGS_TO_EAT.
为什么?</li>
</ol>
<p>JavaScript 的语句以分号作为结束符, 除非可以非常准确推断某结束位置才会省略分号. 上面的例子产出错误, 均是在语句中声明了函数 / 对象 / 数组直接量, 但 闭括号 (&#39;}&#39; 或 &#39;]&#39;) 并不足以表示该语句的结束. 在 JavaScript 中, 只有当语句后的下一个符号是后缀或括号运算符时, 才会认为该语句的结束. 参考：<a href="http://justjavac.iteye.com/blog/1852405" target="_blank">JS 分号自动插入机制</a></p>
<p>遗漏分号有时会出现很奇怪的结果, 所以确保语句以分号结束.</p>
<h4 id="-">块内函数声明</h4>
<p>不要在块内声明一个函数，不要写成:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>  <span class="keyword">if</span> (x) {
    <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> {</span>}
  }
</pre></td></tr></table></figure>

<p>虽然很多 JS 引擎都支持块内声明函数, 但它不属于 ECMAScript 规范 (见 <a href="http://www.ecma-international.org/publications/standards/Ecma-262.htm" target="_blank">ECMA-262</a>, 第 13 和 14 条). 各个浏览器糟糕的实现相互不兼容, 有些也与未来 ECMAScript 草案相违背. ECMAScript 只允许在脚本的根语句或函数中声明函数. 如果确实需要在块中定义函数, 建议使用函数表达式来初始化变量:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>  <span class="keyword">if</span> (x) {
    <span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>}
  }
</pre></td></tr></table></figure>

<h4 id="-">标准特性</h4>
<p>标准特性总是优于非标准特性.
最大化可移植性和兼容性, 尽量使用标准方法而不是用非标准方法, (比如, 优先用 string.charAt(3) 而不用 string[3] , 通过 DOM 原生函数访问元素, 而不是使用应用封装好的快速接口.</p>
<h4 id="-">不要封装基本类型</h4>
<p>没有任何理由去封装基本类型, 另外还存在一些风险:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>  <span class="keyword">var</span> x = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);
  <span class="keyword">if</span> (x) {
    alert(<span class="string">'hi'</span>);  <span class="comment">// Shows 'hi'.</span>
  }
</pre></td></tr></table></figure>

<p>除非明确用于类型转换, 其他情况请千万不要这样做！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre>  <span class="keyword">var</span> x = <span class="built_in">Boolean</span>(<span class="number">0</span>);
  <span class="keyword">if</span> (x) {
    alert(<span class="string">'hi'</span>);  <span class="comment">// This will never be alerted.</span>
  }
  <span class="keyword">typeof</span> <span class="built_in">Boolean</span>(<span class="number">0</span>) == <span class="string">'boolean'</span>;
  <span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">0</span>) == <span class="string">'object'</span>;
</pre></td></tr></table></figure>

<p>有时用作 number, string 或 boolean 时, 类型的转换会非常实用.</p>
<h4 id="-">闭包</h4>
<p>可以, 但小心使用.
闭包也许是 JS 中最有用的特性了. 有一份比较好的介绍闭包原理的<a href="http://jibbering.com/faq/notes/closures/" target="_blank">文档</a>.</p>
<p>有一点需要牢记, 闭包保留了一个指向它封闭作用域的指针, 所以, 在给 DOM 元素附加闭包时, 很可能会产生循环引用, 进一步导致内存泄漏. 比如下面的代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>  <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(element, a, b)</span> {</span>
    element.onclick = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span> <span class="comment">/* uses a and b */</span> };
  }
</pre></td></tr></table></figure>

<p>这里, 即使没有使用 element, 闭包也保留了 element, a 和 b 的引用, 由于 element 也保留了对闭包的引用, 这就产生了循环引用, 这就不能被 GC 回收. 这种情况下, 可将代码重构为:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>  <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(element, a, b)</span> {</span>
    element.onclick = bar(a, b);
  }

  <span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">(a, b)</span> {</span>
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span> <span class="comment">/* uses a and b */</span> }
  }
</pre></td></tr></table></figure>

<h4 id="eval-">eval()</h4>
<p>只用于解析序列化串 (如: 解析 RPC 响应), 而且解析序列号字符串用 JSON.parse() 会更好，所以最好放弃使用 eval().
eval() 会让程序执行的比较混乱, 当 eval() 里面包含用户输入的话就更加危险. 可以用其他更佳的, 更清晰, 更安全的方式写你的代码, 所以一般情况下请不要使用 eval(). 当碰到一些需要解析序列化串的情况下 (如, 计算 RPC 响应), 使用 eval 很容易实现.</p>
<p>解析序列化串是指将字节流转换成内存中的数据结构. 比如, 你可能会将一个对象输出成文件形式:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>  users = [
    {
      name: <span class="string">'Eric'</span>,
      id: <span class="number">37824</span>,
      email: <span class="string">'jellyvore@myway.com'</span>
    },
    {
      name: <span class="string">'xtof'</span>,
      id: <span class="number">31337</span>,
      email: <span class="string">'b4d455h4x0r@google.com'</span>
    },
    ...
  ];
</pre></td></tr></table></figure>

<p>很简单地调用 eval 后, 把表示成文件的数据读取回内存中.</p>
<p>类似的, eval() 对 RPC 响应值进行解码. 例如, 你在使用 XMLHttpRequest 发出一个 RPC 请求后, 通过 eval () 将服务端的响应文本转成 JavaScript 对象:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>  <span class="keyword">var</span> userOnline = <span class="literal">false</span>;
  <span class="keyword">var</span> user = <span class="string">'nusrat'</span>;
  <span class="keyword">var</span> xmlhttp = <span class="keyword">new</span> XMLHttpRequest();
  xmlhttp.open(<span class="string">'GET'</span>, <span class="string">'http://chat.google.com/isUserOnline?user='</span> + user, <span class="literal">false</span>);
  xmlhttp.send(<span class="string">''</span>);
  <span class="comment">// Server returns:</span>
  <span class="comment">// userOnline = true;</span>
  <span class="keyword">if</span> (xmlhttp.status == <span class="number">200</span>) {
    <span class="built_in">eval</span>(xmlhttp.responseText);
  }
  <span class="comment">// userOnline is now true.</span>
</pre></td></tr></table></figure>

<h4 id="with-">with() {}</h4>
<p>不要使用
使用 with 让你的代码在语义上变得不清晰. 因为 with 的对象, 可能会与局部变量产生冲突, 从而改变你程序原本的用义. 下面的代码是干嘛的?</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>  <span class="keyword">with</span> (foo) {
    <span class="keyword">var</span> x = <span class="number">3</span>;
    <span class="keyword">return</span> x;
  }
</pre></td></tr></table></figure>

<p>答案: 任何事. 局部变量 x 可能被 foo 的属性覆盖, 当它定义一个 setter 时, 在赋值 3 后会执行很多其他代码. 所以不要使用 with 语句.</p>
<h4 id="this">this</h4>
<p>仅在对象构造器, 方法, 闭包中使用.
this 的语义很特别. 有时它引用一个全局对象 (大多数情况下), 调用者的作用域 (使用 eval 时), DOM 树中的节点 (添加事件处理函数时), 新创建的对象 (使用一个构造器), 或者其他对象 (如果函数被 call() 或 apply()).</p>
<p>使用时很容易出错, 所以只有在下面两个情况时才能使用:</p>
<ul>
<li>在构造器中</li>
<li>对象的方法 (包括创建的闭包) 中</li>
</ul>
<h4 id="for-in-">for-in 循环</h4>
<p>只用于 object/map/hash 的遍历
对 Array 用 for-in 循环有时会出错. 因为它并不是从 0 到 length - 1 进行遍历, 而是所有出现在对象及其原型链的键值. 下面就是一些失败的使用案例:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre>  <span class="function"><span class="keyword">function</span> <span class="title">printArray</span><span class="params">(arr)</span> {</span>
    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> arr) {
      print(arr[key]);
    }
  }

  printArray([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);  <span class="comment">// This works.</span>

  <span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>);
  printArray(a);  <span class="comment">// This is wrong.</span>

  a = document.getElementsByTagName(<span class="string">'*'</span>);
  printArray(a);  <span class="comment">// This is wrong.</span>

  a = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];
  a.buhu = <span class="string">'wine'</span>;
  printArray(a);  <span class="comment">// This is wrong again.</span>

  a = <span class="keyword">new</span> <span class="built_in">Array</span>;
  a[<span class="number">3</span>] = <span class="number">3</span>;
  printArray(a);  <span class="comment">// This is wrong again.</span>

  <span class="comment">// 而遍历数组通常用最普通的 for 循环.</span>
  <span class="function"><span class="keyword">function</span> <span class="title">printArray</span><span class="params">(arr)</span> {</span>
    <span class="keyword">var</span> l = arr.length;
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; l; i++) {
      print(arr[i]);
    }
  }
</pre></td></tr></table></figure>

<h4 id="-">多行字符串</h4>
<p>不要使用. 不要这样写长字符串:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="keyword">var</span> myString = <span class="string">'A rather long string of English text, an error message \
                actually that just keeps going and going -- an error \
                message to make the Energizer bunny blush (right through \
                those Schwarzenegger shades)! Where was I? Oh yes, \
                you\'ve got an error and all the extraneous whitespace is \
                just gravy.  Have a nice day.'</span>;
</pre></td></tr></table></figure>

<p>在编译时, 不能忽略行起始位置的空白字符 ; &quot;\&quot; 后的空白字符会产生奇怪的错误 ; 虽然大多数脚本引擎支持这种写法, 但它不是 ECMAScript 的标准规范.</p>
<h4 id="array-object-">Array 和 Object 直接量</h4>
<p>使用 Array 和 Object 语法, 而不使用 Array 和 Object 构造器.</p>
<p>使用 Array 构造器很容易因为传参不恰当导致错误.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre>  <span class="comment">// Length is 3.</span>
  <span class="keyword">var</span> a1 = <span class="keyword">new</span> <span class="built_in">Array</span>(x1, x2, x3);

  <span class="comment">// Length is 2.</span>
  <span class="keyword">var</span> a2 = <span class="keyword">new</span> <span class="built_in">Array</span>(x1, x2);

  <span class="comment">// If x1 is a number and it is a natural number the length will be x1.</span>
  <span class="comment">// If x1 is a number but not a natural number this will throw an exception.</span>
  <span class="comment">// Otherwise the array will have one element with x1 as its value.</span>
  <span class="keyword">var</span> a3 = <span class="keyword">new</span> <span class="built_in">Array</span>(x1);

  <span class="comment">// Length is 0.</span>
  <span class="keyword">var</span> a4 = <span class="keyword">new</span> <span class="built_in">Array</span>();
</pre></td></tr></table></figure>

<p>如果传入一个参数而不是 2 个参数, 数组的长度很有可能就不是你期望的数值了.</p>
<p>为了避免这些歧义, 我们应该使用更易读的直接量来声明.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>  <span class="keyword">var</span> a = [x1, x2, x3];
  <span class="keyword">var</span> a2 = [x1, x2];
  <span class="keyword">var</span> a3 = [x1];
  <span class="keyword">var</span> a4 = [];
</pre></td></tr></table></figure>

<p>虽然 Object 构造器没有上述类似的问题, 但鉴于可读性和一致性考虑, 最好还是在字面上更清晰地指明. 例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();

  <span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="built_in">Object</span>();
  o2.a = <span class="number">0</span>;
  o2.b = <span class="number">1</span>;
  o2.c = <span class="number">2</span>;
  o2[<span class="string">'strange key'</span>] = <span class="number">3</span>;
</pre></td></tr></table></figure>

<p>应该写成:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>  <span class="keyword">var</span> o = {};

  <span class="keyword">var</span> o2 = {
    a: <span class="number">0</span>,
    b: <span class="number">1</span>,
    c: <span class="number">2</span>,
    <span class="string">'strange key'</span>: <span class="number">3</span>
  };
</pre></td></tr></table></figure>

<h4 id="-">不要修改内置对象的原型</h4>
<p>千万不要修改内置对象, 如 Object.prototype 和 Array.prototype 的原型. 而修改内置对象, 如 Function.prototype 的原型, 虽然少危险些, 但仍会导致调试时的诡异现象. 所以也要避免修改其原型.</p>
<h3 id="javascript-tips-and-tricks-">JavaScript 小技巧 (Tips and Tricks)</h3>
<h4 id="true-false-">True 和 False 布尔表达式</h4>
<p>下面的布尔表达式都返回 false:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre><span class="literal">null</span>
<span class="literal">undefined</span>
<span class="string">''</span>          <span class="comment">// 空字符串</span>
<span class="number">0</span>           <span class="comment">// 数字 0</span>
</pre></td></tr></table></figure>

<p>但小心下面的, 可都返回 true:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="string">'0'</span>   <span class="comment">// 字符串 0</span>
[]    <span class="comment">// 空数组</span>
{}    <span class="comment">// 空对象</span>
</pre></td></tr></table></figure>

<p>下面段比较糟糕的代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">while</span> (x != <span class="literal">null</span>) {
</pre></td></tr></table></figure>

<p>你可以直接写成下面的形式 (只要你希望 x 不是 0 和空字符串, 和 false):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">while</span> (x) {
</pre></td></tr></table></figure>

<p>如果你想检查字符串是否为 null 或空:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">if</span> (y != <span class="literal">null</span> && y != <span class="string">''</span>) {
</pre></td></tr></table></figure>

<p>但这样会更好:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="keyword">if</span> (y) {
</pre></td></tr></table></figure>

<p>注意: 还有很多需要注意的地方, 如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="code"><pre>    <span class="built_in">Boolean</span>(<span class="string">'0'</span>) == <span class="literal">true</span>
    <span class="string">'0'</span> != <span class="literal">true</span>
    <span class="number">0</span> != <span class="literal">null</span>
    <span class="number">0</span> == []
    <span class="number">0</span> == <span class="literal">false</span>
    <span class="built_in">Boolean</span>(<span class="literal">null</span>) == <span class="literal">false</span>
    <span class="literal">null</span> != <span class="literal">true</span>
    <span class="literal">null</span> != <span class="literal">false</span>
    <span class="built_in">Boolean</span>(<span class="literal">undefined</span>) == <span class="literal">false</span>
    <span class="literal">undefined</span> != <span class="literal">true</span>
    <span class="literal">undefined</span> != <span class="literal">false</span>
    <span class="built_in">Boolean</span>([]) == <span class="literal">true</span>
    [] != <span class="literal">true</span>
    [] == <span class="literal">false</span>
    <span class="built_in">Boolean</span>({}) == <span class="literal">true</span>
    {} != <span class="literal">true</span>
    {} != <span class="literal">false</span>
</pre></td></tr></table></figure>

<h4 id="-">条件 (三元) 操作符 (?:)</h4>
<p>三元操作符用于替代下面的代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>    <span class="keyword">if</span> (val != <span class="number">0</span>) {
      <span class="keyword">return</span> foo();
    } <span class="keyword">else</span> {
      <span class="keyword">return</span> bar();
    }
</pre></td></tr></table></figure>

<p>你可以写成:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>  <span class="keyword">return</span> val ? foo() : bar();
</pre></td></tr></table></figure>

<p>在生成 HTML 代码时也是很有用的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>  <span class="keyword">var</span> html = <span class="string">'&lt;input type="checkbox"'</span> +
      (isChecked ? <span class="string">' checked'</span> : <span class="string">''</span>) +
      (isEnabled ? <span class="string">''</span> : <span class="string">' disabled'</span>) +
      <span class="string">' name="foo"&gt;'</span>;
</pre></td></tr></table></figure>

<h4 id="-">&amp;&amp; 和 ||</h4>
<p>二元布尔操作符是可短路的, 只有在必要时才会计算到最后一项.</p>
<p>&quot;||&quot; 被称作为 &#39;default&#39; 操作符, 因为可以这样:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
</pre></td><td class="code"><pre>    <span class="comment">/** @param {*=} opt_win */</span>
    <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(opt_win)</span> {</span>
      <span class="keyword">var</span> win;
      <span class="keyword">if</span> (opt_win) {
        win = opt_win;
      } <span class="keyword">else</span> {
        win = window;
      }
      <span class="comment">// ...</span>
    }
</pre></td></tr></table></figure>

<p>你可以使用它来简化上面的代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>    <span class="comment">/** @param {*=} opt_win */</span>
    <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(opt_win)</span> {</span>
      <span class="keyword">var</span> win = opt_win || window;
      <span class="comment">// ...</span>
    }
</pre></td></tr></table></figure>

<p>&quot;&amp;&amp;&quot; 也可简短代码. 比如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>    <span class="keyword">if</span> (node) {
      <span class="keyword">if</span> (node.kids) {
        <span class="keyword">if</span> (node.kids[index]) {
          foo(node.kids[index]);
        }
      }
    }
</pre></td></tr></table></figure>

<p>你可以像这样来使用:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre>    <span class="keyword">if</span> (node && node.kids && node.kids[index]) {
      foo(node.kids[index]);
    }
</pre></td></tr></table></figure>

<p>或者:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>    <span class="keyword">var</span> kid = node && node.kids && node.kids[index];
    <span class="keyword">if</span> (kid) {
      foo(kid);
    }
</pre></td></tr></table></figure>

<p>不过这样就有点儿过头了:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>    node && node.kids && node.kids[index] && foo(node.kids[index]);
</pre></td></tr></table></figure>

<h4 id="-join-">使用 join() 来创建字符串</h4>
<p>通常是这样使用的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>    <span class="function"><span class="keyword">function</span> <span class="title">listHtml</span><span class="params">(items)</span> {</span>
      <span class="keyword">var</span> html = <span class="string">'&lt;div class="foo"&gt;'</span>;
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; items.length; ++i) {
        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) {
          html += <span class="string">', '</span>;
        }
        html += itemHtml(items[i]);
      }
      html += <span class="string">'&lt;/div&gt;'</span>;
      <span class="keyword">return</span> html;
    }
</pre></td></tr></table></figure>

<p>但这样在 IE 下非常慢, 可以用下面的方式:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>    <span class="function"><span class="keyword">function</span> <span class="title">listHtml</span><span class="params">(items)</span> {</span>
      <span class="keyword">var</span> html = [];
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; items.length; ++i) {
        html[i] = itemHtml(items[i]);
      }
      <span class="keyword">return</span> <span class="string">'&lt;div class="foo"&gt;'</span> + html.join(<span class="string">', '</span>) + <span class="string">'&lt;/div&gt;'</span>;
    }
</pre></td></tr></table></figure>

<p>你也可以是用数组作为字符串构造器, 然后通过 myArray.join(&#39;&#39;) 转换成字符串. 不过由于赋值操作快于数组的 push(), 所以尽量使用赋值操作.</p>
<h4 id="-jquery-core-style-guidelines-">类型检测 (来源于 jQuery Core Style Guidelines)</h4>
<ul>
<li><p>直接类型（实际类型，Actual Types）</p>
<p>  String:</p>
<pre><code>  typeof variable === &quot;string&quot;
</code></pre><p>  Number:</p>
<pre><code>  typeof variable === &quot;number&quot;
</code></pre><p>  Boolean:</p>
<pre><code>  typeof variable === &quot;boolean&quot;
</code></pre><p>  Object:</p>
<pre><code>  typeof variable === &quot;object&quot;
</code></pre><p>  Array:</p>
<pre><code>  Array.isArray(arrayLikeObject)
  (如果可能的话)
</code></pre><p>  Node:</p>
<pre><code>  elem.nodeType === 1
</code></pre><p>  null:</p>
<pre><code>  variable === null
</code></pre><p>  null or undefined:</p>
<pre><code>  variable == null
</code></pre><p>  undefined:</p>
<pre><code>全局变量:

  typeof variable === &quot;undefined&quot;

局部变量:

  variable === undefined

属性:

  object.prop === undefined
  object.hasOwnProperty(prop)
  &quot;prop&quot; in object
</code></pre></li>
<li><p>转换类型（强制类型，Coerced Types）</p>
<p>  考虑下面这个的含义...</p>
<p>  给定的 HTML:</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre>
    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">id</span>=<span class="value">"foo-input"</span> <span class="attribute">value</span>=<span class="value">"1"</span>&gt;</span>
</pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre>
    <span class="comment">// `foo` 已经被赋予值 `0`，类型为 `number`</span>
    <span class="keyword">var</span> foo = <span class="number">0</span>;

    <span class="comment">// typeof foo;</span>
    <span class="comment">// "number"</span>
    ...

    <span class="comment">// 在后续的代码中，你需要更新 `foo`，赋予在 input 元素中得到的新值</span>

    foo = document.getElementById(<span class="string">"foo-input"</span>).value;

    <span class="comment">// 如果你现在测试 `typeof foo`, 结果将是 `string`</span>
    <span class="comment">// 这意味着你在 if 语句检测 `foo` 有类似于此的逻辑:</span>

    <span class="keyword">if</span> (foo === <span class="number">1</span>) {
      importantTask();
    }

    <span class="comment">// `importantTask()` 将永远不会被执行，即使 `foo` 有一个值 "1"</span>

    <span class="comment">// 你可以巧妙地使用 + / - 一元运算符强制转换类型以解决问题:</span>

    foo = +document.getElementById(<span class="string">"foo-input"</span>).value;
    <span class="comment">//    ^ + 一元运算符将它右边的运算对象转换为 `number`</span>

    <span class="comment">// typeof foo;</span>
    <span class="comment">// "number"</span>

    <span class="keyword">if</span> (foo === <span class="number">1</span>) {
      importantTask();
    }

    <span class="comment">// `importantTask()` 将被调用</span>
</pre></td></tr></table></figure>

<pre><code>对于强制类型转换这里有几个例子:
</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td><td class="code"><pre>
    <span class="keyword">var</span> number = <span class="number">1</span>,
      string = <span class="string">"1"</span>,
      bool = <span class="literal">false</span>;

    number;
    <span class="comment">// 1</span>

    number + <span class="string">""</span>;
    <span class="comment">// "1"</span>

    string;
    <span class="comment">// "1"</span>

    +string;
    <span class="comment">// 1</span>

    +string++;
    <span class="comment">// 1</span>

    string;
    <span class="comment">// 2</span>

    bool;
    <span class="comment">// false</span>

    +bool;
    <span class="comment">// 0</span>

    bool + <span class="string">""</span>;
    <span class="comment">// "false"</span>
</pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre>
    <span class="keyword">var</span> number = <span class="number">1</span>,
      string = <span class="string">"1"</span>,
      bool = <span class="literal">true</span>;

    string === number;
    <span class="comment">// false</span>

    string === number + <span class="string">""</span>;
    <span class="comment">// true</span>

    +string === number;
    <span class="comment">// true</span>

    bool === number;
    <span class="comment">// false</span>

    +bool === number;
    <span class="comment">// true</span>

    bool === string;
    <span class="comment">// false</span>

    bool === !!string;
    <span class="comment">// true</span>
</pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre>
    <span class="keyword">var</span> num = <span class="number">2.5</span>;

    <span class="built_in">parseInt</span>(num, <span class="number">10</span>);

    <span class="comment">// 等价于...</span>

    ~~num;

    num &gt;&gt; <span class="number">0</span>;

    num &gt;&gt;&gt; <span class="number">0</span>;

    <span class="comment">// 结果都是 2</span>


    <span class="comment">// 时刻牢记心底, 负值将被区别对待...</span>

    <span class="keyword">var</span> neg = -<span class="number">2.5</span>;

    <span class="built_in">parseInt</span>(neg, <span class="number">10</span>);

    <span class="comment">// 等价于...</span>

    ~~neg;

    neg &gt;&gt; <span class="number">0</span>;

    <span class="comment">// 结果都是 -2</span>
    <span class="comment">// 但是...</span>

    neg &gt;&gt;&gt; <span class="number">0</span>;

    <span class="comment">// 结果即是 4294967294</span>
</pre></td></tr></table></figure>

<ul>
<li>字符串转换为整数</li>
</ul>
<p>将字符串转换为整数有以下几种方式，可以在<a href="http://jsperf.com/converting-string-to-int/2" target="_blank">这里</a>进行测试对比：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre>    <span class="keyword">var</span> number1 = <span class="string">"45"</span>;
    <span class="comment">// ParseInt() Test on chrome for mac:31% slower</span>
    <span class="keyword">var</span> i = <span class="built_in">parseInt</span>(number1);
    <span class="comment">// Using unary Test on chrome for mac:67% slower</span>
    <span class="keyword">var</span> j = +number1;
    <span class="comment">// Number constructor Test on chrome for mac:59% slower</span>
    <span class="keyword">var</span> k = <span class="built_in">Number</span>(number1);
    <span class="comment">// By multplication Test on chrome for mac:69% slower</span>
    <span class="keyword">var</span> l = number1 * <span class="number">1</span>;
    <span class="comment">// parseInt with Test on chrome for mac:radix ±3.85% fastest</span>
    <span class="keyword">var</span> m = <span class="built_in">parseInt</span>(number1, <span class="number">10</span>);
</pre></td></tr></table></figure>

<p>所以推荐使用 parseInt(number1, 10) 这种方式，不过 +number1 更为简单，在操作次数极少的情况下也可以酌情使用。</p>
<h4 id="-">对比运算</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre></td><td class="code"><pre>    <span class="comment">// 当只是判断一个 array 是否有长度，相对于使用这个:</span>
    <span class="keyword">if</span> (array.length &gt; <span class="number">0</span>) ...

    <span class="comment">// ... 判断真伪, 请使用这种:</span>
    <span class="keyword">if</span> (array.length) ...

    <span class="comment">// 当只是判断一个 array 是否为空，相对于使用这个:</span>
    <span class="keyword">if</span> (array.length === <span class="number">0</span>) ...

    <span class="comment">// ... 判断真伪, 请使用这种:</span>
    <span class="keyword">if</span> (!array.length) ...

    <span class="comment">// 当只是判断一个 string 是否为空，相对于使用这个:</span>
    <span class="keyword">if</span> (string !== <span class="string">""</span>) ...

    <span class="comment">// ... 判断真伪, 请使用这种:</span>
    <span class="keyword">if</span> (string) ...

    <span class="comment">// 当只是判断一个 string 是为空，相对于使用这个:</span>
    <span class="keyword">if</span> (string === <span class="string">""</span>) ...

    <span class="comment">// ... 判断真伪, 请使用这种:</span>
    <span class="keyword">if</span> (!string) ...

    <span class="comment">// 当只是判断一个引用是为真，相对于使用这个:</span>
    <span class="keyword">if</span> (foo === <span class="literal">true</span>) ...

    <span class="comment">// ... 判断只需像你所想，享受内置功能的好处:</span>
    <span class="keyword">if</span> (foo) ...

    <span class="comment">// 当只是判断一个引用是为假，相对于使用这个:</span>
    <span class="keyword">if</span> (foo === <span class="literal">false</span>) ...

    <span class="comment">// ... 使用叹号将其转换为真</span>
    <span class="keyword">if</span> (!foo) ...

    <span class="comment">// ... 需要注意的是：这个将会匹配 0, "", null, undefined, NaN</span>
    <span class="comment">// 如果你 _ 必须 _ 是布尔类型的 false，请这样用：</span>
    <span class="keyword">if</span> (foo === <span class="literal">false</span>) ...

    <span class="comment">// 如果想计算一个引用可能是 null 或者 undefined，但并不是 false, "" 或者 0,</span>
    <span class="comment">// 相对于使用这个：</span>
    <span class="keyword">if</span> (foo === <span class="literal">null</span> || foo === <span class="literal">undefined</span>) ...

    <span class="comment">// ... 享受 == 类型强制转换的好处，像这样:</span>
    <span class="keyword">if</span> (foo == <span class="literal">null</span>) ...

    <span class="comment">// 谨记，使用 == 将会令 `null` 匹配 `null` 和 `undefined`</span>
    <span class="comment">// 但不是 `false`，"" 或者 0</span>
    <span class="literal">null</span> == <span class="literal">undefined</span>
</pre></td></tr></table></figure>

<p>总是判断最好、最精确的值，上述是指南而非教条。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre>    <span class="comment">// 类型转换和对比运算说明</span>
    <span class="comment">// 首次 `===`，`==` 次之 (除非需要松散类型的对比)</span>
    <span class="comment">// `===` 总不做类型转换，这意味着:</span>
    <span class="string">"1"</span> === <span class="number">1</span>;
    <span class="comment">// false</span>

    <span class="comment">// `==` 会转换类型，这意味着:</span>
    <span class="string">"1"</span> == <span class="number">1</span>;
    <span class="comment">// true</span>

    <span class="comment">// 布尔, 真 & 伪</span>
    <span class="comment">// 布尔:</span>
    <span class="literal">true</span>, <span class="literal">false</span>

    <span class="comment">// 真:</span>
    <span class="string">"foo"</span>, <span class="number">1</span>

    <span class="comment">// 伪:</span>
    <span class="string">""</span>, <span class="number">0</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="keyword">void</span> <span class="number">0</span>
</pre></td></tr></table></figure>

<h4 id="misc">Misc</h4>
<p>这个部分将要说明的想法和理念都并非教条。相反更鼓励对现存实践保持好奇，以尝试提供完成一般 JavaScript 编程任务的更好方案。</p>
<ul>
<li>提前返回值提升代码的可读性并且没有太多性能上的差别</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre>
    <span class="comment">// 不好:</span>
    <span class="function"><span class="keyword">function</span> <span class="title">returnLate</span><span class="params">(foo)</span> {</span>
      <span class="keyword">var</span> ret;

      <span class="keyword">if</span> (foo) {
        ret = <span class="string">"foo"</span>;
      } <span class="keyword">else</span> {
        ret = <span class="string">"quux"</span>;
      }
      <span class="keyword">return</span> ret;
    }

    <span class="comment">// 好:</span>
    <span class="function"><span class="keyword">function</span> <span class="title">returnEarly</span><span class="params">(foo)</span> {</span>

      <span class="keyword">if</span> (foo) {
        <span class="keyword">return</span> <span class="string">"foo"</span>;
      }
      <span class="keyword">return</span> <span class="string">"quux"</span>;
    }
</pre></td></tr></table></figure>

<ul>
<li>for 循环遍历</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>    <span class="comment">// for 循环遍历:</span>
    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, l = arr.length; i &lt; l; i++){
        <span class="comment">// doSomething here</span>
    }
    <span class="comment">// 上面的方式优于:</span>
    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++){
        <span class="comment">// doSomething here</span>
    }
    <span class="comment">// 前一种方式只会计算一次 arr 的长度，而后一种方式会计算 arr.length + 1 次，效率比较低</span>
</pre></td></tr></table></figure>

<h2 id="-">保持一致性.</h2>
<p>当你在编辑代码之前, 先花一些时间查看一下现有代码的风格. 如果他们给算术运算符添加了空格, 你也应该添加. 如果他们的注释使用一个个星号盒子, 那么也请你使用这种方式.</p>
<p>代码风格中一个关键点是整理一份常用词汇表, 开发者认同它并且遵循, 这样在代码中就能统一表述. 我们在这提出了一些全局上的风格规则, 但也要考虑自身情况形成自己的代码风格. 但如果你添加的代码和现有的代码有很大的区别, 这就让阅读者感到很不和谐. 所以, 避免这种情况的发生.</p>

      
    </div>
    <footer>
      

        
          <div class="alignleft post-nav">
            <em>上一篇: </em><a href="/misc/art-gallery/">Art Gallery</a>
          </div>
        
        
          <div class="alignright post-nav">
            <em>下一篇: </em><a href="/investment/delisting-rules/">美股退市规则</a>
          </div>
          <div class="clearfix"></div>
        

        
          <div class="copyright">
            
              <span class="claim">版权声明：自由转载-非商用-无演绎-保持署名 @ Creative Commons BY-NC-ND 3.0</span>
            
            
              <span class="from-link">
                <em>本文链接地址:</em> 
                <a href="/tech/js-style/">
                  http://topdna.org/tech/js-style/
                </a>
              </span>
            
          </div>
        
        
  
  <div class="categories">
    <a href="/categories/tech/">技术</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/tech/">技术</a>, <a href="/tags/JavaScript/">JavaScript</a>, <a href="/tags/frontend/">前端</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">留言</h1>
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="text" name="q" results="0" placeholder="搜一下">
    <i class="icon-search"></i>
    <input type="hidden" name="q" value="site:topdna.org">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/Express/">Express</a><small>1</small></li>
  
    <li><a href="/tags/Jade/">Jade</a><small>1</small></li>
  
    <li><a href="/tags/JavaScript/">JavaScript</a><small>1</small></li>
  
    <li><a href="/tags/Mongodb/">Mongodb</a><small>1</small></li>
  
    <li><a href="/tags/Nodejs/">Nodejs</a><small>1</small></li>
  
    <li><a href="/tags/misc/">其他</a><small>1</small></li>
  
    <li><a href="/tags/frontend/">前端</a><small>1</small></li>
  
    <li><a href="/tags/tech/">技术</a><small>5</small></li>
  
    <li><a href="/tags/travel/">旅行</a><small>2</small></li>
  
    <li><a href="/tags/investment/">理财</a><small>4</small></li>
  
    <li><a href="/tags/life/">生活</a><small>10</small></li>
  
    <li><a href="/tags/reading/">读书</a><small>2</small></li>
  
    <li><a href="/tags/essay/">随感</a><small>27</small></li>
  
  </ul>
</div>


  <div class="trace-invest">
    <span>
        <a href="http://traceinvest.com" target="_blank">欢迎光临我的美股投资相关网站 :</br>traceinvest.com</a>
    </span>
</div>


  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/essay/blankness/">空白</a>
      </li>
    
      <li>
        <a href="/investment/capital-gains-tax/">关于美国资本利得税</a>
      </li>
    
      <li>
        <a href="/tech/mac-software/">Mac下常用软件推荐</a>
      </li>
    
      <li>
        <a href="/investment/reading-list/">Reading List (to Be Continued)</a>
      </li>
    
      <li>
        <a href="/tech/kindwill-domain-for-sale/">Domain for Sale——Kindwill.Com</a>
      </li>
    
      <li>
        <a href="/tech/sublime-shortcuts/">Sublime Text Shortcuts for Mac Os</a>
      </li>
    
      <li>
        <a href="/misc/art-gallery/">Art Gallery</a>
      </li>
    
      <li>
        <a href="/tech/js-style/">Java Script 编码规范</a>
      </li>
    
      <li>
        <a href="/investment/delisting-rules/">美股退市规则</a>
      </li>
    
      <li>
        <a href="/investment/about-some-books/">从几本书说开去</a>
      </li>
    
      <li>
        <a href="/tech/dance-training-manage-system/">Dance Training Manage System Based on Mongo Db and Node</a>
      </li>
    
      <li>
        <a href="/life/the-beauty-of-county/">歙县之美</a>
      </li>
    
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <div id="go-pg-top"><i class="icon-arrow-up"></i></div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2014 hustcer
  
</div>
<div class="clearfix"></div></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<script type="text/javascript">
var disqus_shortname = 'topdna';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>



<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript" charset="utf-8" src="/js/page.js"></script>

</body>

<div id="fb-root"></div>

</html>